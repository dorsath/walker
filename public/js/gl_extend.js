// Generated by CoffeeScript 1.3.3
(function() {

  this.start = function() {
    var canvas;
    canvas = document.getElementById("glcanvas");
    window.gl = canvas.getContext("experimental-webgl");
    gl.mvMatrix = Matrix.I(4);
    gl.perspectiveMatrix = Matrix.I(4);
    gl.mvMatrixStack = [];
    gl.getShader = function(gl, id) {
      var currentChild, shader, shaderScript, theSource;
      shaderScript = document.getElementById(id);
      if (!shaderScript) {
        return null;
      }
      theSource = "";
      currentChild = shaderScript.firstChild;
      while (currentChild) {
        if (currentChild.nodeType === 3) {
          theSource += currentChild.textContent;
        }
        currentChild = currentChild.nextSibling;
      }
      if (shaderScript.type === "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type === "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return;
      }
      gl.shaderSource(shader, theSource);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    };
    gl.initShaders = function() {
      var fragmentShader, vertexShader;
      fragmentShader = gl.getShader(gl, "shader-fs");
      vertexShader = gl.getShader(gl, "shader-vs");
      this.shaderProgram = gl.createProgram();
      gl.attachShader(this.shaderProgram, vertexShader);
      gl.attachShader(this.shaderProgram, fragmentShader);
      gl.linkProgram(this.shaderProgram);
      if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
      }
      gl.useProgram(this.shaderProgram);
      this.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
      gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
      this.shaderProgram.vertexNormalAttribute = gl.getAttribLocation(this.shaderProgram, "aVertexNormal");
      gl.enableVertexAttribArray(this.shaderProgram.vertexNormalAttribute);
      this.shaderProgram.textureCoordAttribute = gl.getAttribLocation(this.shaderProgram, "aTextureCoord");
      gl.enableVertexAttribArray(this.shaderProgram.textureCoordAttribute);
      this.shaderProgram.pMatrixUniform = gl.getUniformLocation(this.shaderProgram, "uPMatrix");
      this.shaderProgram.mvMatrixUniform = gl.getUniformLocation(this.shaderProgram, "uMVMatrix");
      this.shaderProgram.nMatrixUniform = gl.getUniformLocation(this.shaderProgram, "uNMatrix");
      this.shaderProgram.samplerUniform = gl.getUniformLocation(this.shaderProgram, "uSampler");
      this.shaderProgram.useLightingUniform = gl.getUniformLocation(this.shaderProgram, "uUseLighting");
      this.shaderProgram.ambientColorUniform = gl.getUniformLocation(this.shaderProgram, "uAmbientColor");
      this.shaderProgram.lightingDirectionUniform = gl.getUniformLocation(this.shaderProgram, "uLightingDirection");
      return this.shaderProgram.directionalColorUniform = gl.getUniformLocation(this.shaderProgram, "uDirectionalColor");
    };
    gl.handleLoadedTexture = function(texture) {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);
      return gl.bindTexture(gl.TEXTURE_2D, null);
    };
    gl.loadIdentity = function() {
      this.mvMatrix = Matrix.I(4);
      return this.setMatrixUniforms();
    };
    gl.multMatrix = function(m) {
      return this.mvMatrix = this.mvMatrix.x(m);
    };
    gl.mvTranslate = function(v) {
      return this.multMatrix(Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4());
    };
    gl.setMatrixUniforms = function() {
      var mvUniform, pUniform;
      pUniform = gl.getUniformLocation(this.shaderProgram, "uPMatrix");
      gl.uniformMatrix4fv(pUniform, false, new Float32Array(this.perspectiveMatrix.flatten()));
      mvUniform = gl.getUniformLocation(this.shaderProgram, "uMVMatrix");
      return gl.uniformMatrix4fv(mvUniform, false, new Float32Array(this.mvMatrix.flatten()));
    };
    gl.mvPushMatrix = function(m) {
      if (m) {
        this.mvMatrixStack.push(m.dup());
        return this.mvMatrix = m.dup();
      } else {
        return this.mvMatrixStack.push(this.mvMatrix.dup());
      }
    };
    gl.mvPopMatrix = function() {
      if (!this.mvMatrixStack.length) {
        throw "Can't pop from an empty matrix stack.";
      }
      this.mvMatrix = this.mvMatrixStack.pop();
      return this.mvMatrix;
    };
    gl.mvRotate = function(angle, v) {
      var inRadians, m;
      inRadians = angle * Math.PI / 180.0;
      m = Matrix.Rotation(inRadians, $V([v[0], v[1], v[2]])).ensure4x4();
      return gl.multMatrix(m);
    };
    gl.normalMatrix = function() {
      var nUniform, normMatrix;
      normMatrix = gl.mvMatrix.inverse();
      normMatrix = normMatrix.transpose();
      nUniform = gl.getUniformLocation(this.shaderProgram, "uNormalMatrix");
      return gl.uniformMatrix4fv(nUniform, false, new WebGLFloatArray(normMatrix.flatten()));
    };
    return window.walker = new window.walker_object;
  };

}).call(this);
