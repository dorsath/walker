// Generated by CoffeeScript 1.3.3
(function() {

  this.start = function() {
    var canvas;
    canvas = document.getElementById("glcanvas");
    window.gl = canvas.getContext("experimental-webgl");
    gl.mvMatrix = Matrix.I(4);
    gl.perspectiveMatrix = Matrix.I(4);
    gl.mvMatrixStack = [];
    gl.getShader = function(gl, id) {
      var currentChild, shader, shaderScript, theSource;
      shaderScript = document.getElementById(id);
      if (!shaderScript) {
        return null;
      }
      theSource = "";
      currentChild = shaderScript.firstChild;
      while (currentChild) {
        if (currentChild.nodeType === 3) {
          theSource += currentChild.textContent;
        }
        currentChild = currentChild.nextSibling;
      }
      if (shaderScript.type === "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type === "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return;
      }
      gl.shaderSource(shader, theSource);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    };
    gl.initShaders = function() {
      var fragmentShader, vertexColorAttribute, vertexShader;
      fragmentShader = this.getShader(gl, "shader-fs");
      vertexShader = this.getShader(gl, "shader-vs");
      this.shaderProgram = gl.createProgram();
      gl.attachShader(this.shaderProgram, vertexShader);
      gl.attachShader(this.shaderProgram, fragmentShader);
      gl.linkProgram(this.shaderProgram);
      if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {
        alert("Unable to initialize the shader program.");
      }
      gl.useProgram(this.shaderProgram);
      this.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
      gl.enableVertexAttribArray(this.vertexPositionAttribute);
      vertexColorAttribute = gl.getAttribLocation(this.shaderProgram, "aVertexColor");
      return gl.enableVertexAttribArray(vertexColorAttribute);
    };
    gl.loadIdentity = function() {
      this.mvMatrix = Matrix.I(4);
      return this.setMatrixUniforms();
    };
    gl.multMatrix = function(m) {
      return this.mvMatrix = this.mvMatrix.x(m);
    };
    gl.mvTranslate = function(v) {
      return this.multMatrix(Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4());
    };
    gl.setMatrixUniforms = function() {
      var mvUniform, pUniform;
      pUniform = gl.getUniformLocation(this.shaderProgram, "uPMatrix");
      gl.uniformMatrix4fv(pUniform, false, new Float32Array(this.perspectiveMatrix.flatten()));
      mvUniform = gl.getUniformLocation(this.shaderProgram, "uMVMatrix");
      return gl.uniformMatrix4fv(mvUniform, false, new Float32Array(this.mvMatrix.flatten()));
    };
    gl.mvPushMatrix = function(m) {
      if (m) {
        this.mvMatrixStack.push(m.dup());
        return this.mvMatrix = m.dup();
      } else {
        return this.mvMatrixStack.push(this.mvMatrix.dup());
      }
    };
    gl.mvPopMatrix = function() {
      if (!this.mvMatrixStack.length) {
        throw "Can't pop from an empty matrix stack.";
      }
      this.mvMatrix = this.mvMatrixStack.pop();
      return this.mvMatrix;
    };
    gl.mvRotate = function(angle, v) {
      var inRadians, m;
      inRadians = angle * Math.PI / 180.0;
      m = Matrix.Rotation(inRadians, $V([v[0], v[1], v[2]])).ensure4x4();
      return gl.multMatrix(m);
    };
    return window.walker = new window.walker_object;
  };

}).call(this);
